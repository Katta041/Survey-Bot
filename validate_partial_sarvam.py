import os
import pandas as pd
import json
from openai import OpenAI
import framework_config as config
import concurrent.futures

client = OpenAI(api_key=config.OPENAI_API_KEY)

def validate_partial_sarvam():
    # Points to the PARTIAL transcription file
    transcript_path = os.path.join(config.AUDIO_DOWNLOAD_DIR, 'transcribed_metadata_sarvam_partial.csv')
    if not os.path.exists(transcript_path):
        print("Partial Transcript file not found.")
        return

    df = pd.read_csv(transcript_path)
    
    # Filter only rows with transcripts
    df_to_validate = df[df['transcript'] != 'PENDING'].copy()
    print(f"Validating {len(df_to_validate)} records (Partial Check)...")

    # We need to map back to original index or just save a new CSV
    # Let's just save a new partial validation CSV
    
    validation_results = [None] * len(df_to_validate)
    reasons = [None] * len(df_to_validate)
    
    # Convert to list of dicts for safe iteration
    records = df_to_validate.to_dict('records')
    
    def validate_row(idx, row):
        import time
        time.sleep(10.0)
        sample_id = row['sample_id']
        transcript = str(row['transcript'])
        
        # Skip if transcript is missing (should be filtered but double check)
        if "TRANSCRIPT_NOT_FOUND" in transcript or "NO_TRANSCRIPT" in transcript or transcript == 'PENDING':
             return idx, False, "Transcript Missing/Pending"

        data_context = f"""
        Sample ID: {sample_id}
        Reported Q1 (Main Problem): {row.get('Q1', 'N/A')}
        Reported Caste: {row.get('Caste', 'N/A')}
        Reported Age: {row.get('Age', 'N/A')}
        """

        prompt = f"""
        You are a Quality Control Auditor for a Telugu political survey.
        
        TASK:
        Compare the provided TELUGU TRANSCRIPT (generated by Sarvam AI) with the REPORTED DATA.
        
        TRANSCRIPT (Telugu):
        "{transcript}"
        
        REPORTED DATA:
        {data_context}
        
        INSTRUCTIONS:
        1. Check if the transcript contains a conversation relevant to a survey.
        2. Check if the reported data (Problem, Caste, Age) is mentioned or consistent with the audio.
        3. If the audio is empty, noise, or irrelevant, mark as INVALID.
        
        OUTPUT FORMAT:
        Return ONLY a JSON object with two keys:
        - "is_valid": boolean (true/false)
        - "reason": string (brief explanation)
        """

        for attempt in range(5):
            try:
                response = client.chat.completions.create(
                    model=config.VALIDATION_MODEL, 
                    messages=[
                        {"role": "system", "content": "You are a precise data validator."},
                        {"role": "user", "content": prompt}
                    ],
                    response_format={"type": "json_object"},
                    temperature=0
                )
                break
            except Exception as e:
                err_str = str(e).lower()
                if "rate_limit" in err_str or "429" in err_str:
                    import time
                    wait_time = (attempt + 1) * 10
                    print(f"Rate limit for {sample_id} (Attempt {attempt+1}). Retrying in {wait_time}s...")
                    time.sleep(wait_time)
                else:
                    print(f"Error validating {sample_id}: {e}")
                    return idx, False, f"Error: {str(e)}"
        else:
            return idx, False, "Rate limit exceeded after max retries"
            
        try:
            content = response.choices[0].message.content
            try:
                result = json.loads(content)
            except json.JSONDecodeError:
                result = json.loads(content.replace("```json", "").replace("```", ""))

            is_valid = result.get('is_valid', False)
            reason = result.get('reason', 'No reason provided')
            return idx, is_valid, reason
        except Exception as e:
            print(f"Error parsing response for {sample_id}: {e}")
            return idx, False, f"Error parsing: {str(e)}"

    print("Starting concurrent validation...")
    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
        # Submit tasks
        # mapped by index in the *filtered* list
        futures = {executor.submit(validate_row, i, record): i for i, record in enumerate(records)}
        
        for future in concurrent.futures.as_completed(futures):
            idx, is_valid, reason = future.result()
            validation_results[idx] = is_valid
            reasons[idx] = reason
            if idx % 10 == 0:
                print(f"Validated {idx}...")

    df_to_validate['llm_is_valid'] = validation_results
    df_to_validate['llm_reason'] = reasons
    
    output_path = os.path.join(config.AUDIO_DOWNLOAD_DIR, 'validation_results_sarvam_partial.csv')
    df_to_validate.to_csv(output_path, index=False)
    print(f"Partial Validation complete. Results saved to {output_path}")

if __name__ == "__main__":
    validate_partial_sarvam()
